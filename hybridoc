#! /usr/bin/python

import re

from css     import StyleSheet
from css     import parse as parse_css
from css     import render as render_css
from html    import ELEMENTS, VOID, HtmlElement, extant
from html    import render as render_html
from mathml  import parse as parse_math
from inspect import currentframe, getframeinfo
from os      import getcwd, path
from re      import Match as MatchObject
from sys     import argv
from typing  import Optional

SOURCE_DIR   = None  # set in main routine
HYBRIDOC_DIR = path.dirname(path.abspath(argv[0]))

PERMALINK = {1: None, 2: '#', 3: '#', 4: '#', 5: '#', 6: '#'}

# Functions registered to transform code blocks.
HANDLERS = {}

# Populated by style elements.
INLINESTYLES = []

# Populated by module elements.
MODULES = set()

# Maps module name to a CSS file or None.
AVAILABLEMODULES = {
    'base': (1, 'css/base.css'),
    'lite': (2, 'css/lite.css'),
    'dark': (2, 'css/dark.css'),
    'math': (3, 'css/math.css'),
    # fonts
    'alegreya': (0, 'css/fonts/alegreya.css'),
    'at-name':  (0, 'css/fonts/at-name.css' ),
    'bodoni':   (0, 'css/fonts/bodoni.css'  ),
    'century':  (0, 'css/fonts/century.css' ),
    'fira':     (0, 'css/fonts/fira.css'    ),
    'ff-meta':  (0, 'css/fonts/ff-meta.css' ),
    'iosevka':  (0, 'css/fonts/iosevka.css' ),
    'inter':    (0, 'css/fonts/inter.css'   ),
    'new-cm':   (0, 'css/fonts/new-cm.css'  ),
    'operator': (0, 'css/fonts/operator.css'),
    'schotis':  (0, 'css/fonts/schotis.css' ),
    'sudo':     (0, 'css/fonts/sudo.css'    ),
    'victor':   (0, 'css/fonts/victor.css'  ),
    # presets
    'expo-lite': None,
    'expo-dark': None,
}

DEPENDENCIES = {
    'math':      ('schotis', 'bodoni', 'new-cm', 'century'),
    'expo-lite': ('base', 'lite', 'schotis', 'century', 'at-name'),
    'expo-dark': ('base', 'dark', 'ff-meta', 'fira', 'sudo'),
}


# General Utilities  · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·


def _resolve(filename, *dirs):
    for root in dirs:
        res = path.normpath(path.join(root, filename))
        if path.isfile(res):
            return res
    return None


def resolve_module(filename):
    return _resolve(filename, HYBRIDOC_DIR)


def resolve_include(filename):
    return _resolve(filename, SOURCE_DIR, HYBRIDOC_DIR)


def unindent(text):
    lines = text.splitlines()
    lengths = ((len(ln), len(ln.lstrip())) for ln in lines)
    leftskip = min(
        (total - trimmed for total, trimmed in lengths if trimmed > 0),
        default = 0
    )
    return '\n'.join(ln[leftskip:].rstrip() for ln in lines)


# Parsing  · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·


ATTRKEY = re.compile('[a-zA-Z]+(?:-[a-zA-Z]+)*')
ATTRBRK = re.compile('[\\s=\'"]')

def parse_attributes(text : str) -> Optional[dict[str, str]]:
    # We assume there is no leading whitespace,
    #   and maintain that property as an invariant.
    if not text:
        return {}
    parts = []
    while True:
        match = ATTRBRK.search(text)
        if match is None:
            parts.append(text)
            break
        item = text[:match.start()]
        if item:
            parts.append(item)
        char = match[0]
        if char == '=':
            parts.append(None)
            text = text[match.end():].lstrip()
            if text: continue
            break
        if char == '"' or char == "'":
            left = match.end()
            try: right = text.index(char, left)
            except ValueError: return None
            parts.append(text[left:right])
            text = text[right+1:].lstrip()
            if text: continue
            break
        text = text[match.end():].lstrip()
        if not text:
            break
    attrs = {}
    index = 0
    length = len(parts)
    while index < length:
        key = parts[index]
        if key is None: return None # “= ...”
        if not ATTRKEY.fullmatch(key): return None
        if index + 2 < length and parts[index+1] is None:
            value = parts[index+2]
            if value is None: return None # “key = = ...”
            attrs[key] = value
            index += 3
        else:
            attrs[key] = None
            index += 1
    return attrs


def parse_error(text) -> HtmlElement:
    kwargs = {'line-number': getframeinfo(currentframe().f_back).lineno}
    if isinstance(text, str):
        text = text.replace('<', '&lt;').replace('>', '&gt;')
        return HtmlElement('hybridoc-error', text, **kwargs)
    else:
        return HtmlElement('hybridoc-error', *text, **kwargs)


INITIAL  = re.compile('[' + re.escape("$%&'*<@^_`{}\u2020\u203B") + ']')
NONSPACE = re.compile(r'[^ \t\n\r]')

ELEMINI = re.compile('[a-z]')
CUSTOM  = re.compile('[a-z][a-z0-9-]*')
TAGBRK  = re.compile('[>"\']')

WORD    = re.compile('[a-zA-Z]+(?:-[a-zA-Z]+)*')
LETTER  = re.compile('[a-zA-Zα-ωΑ-Ω]')
NUMERAL = re.compile('[+−]?[0-9]+') # U+2212 MINUS SIGN not U+002D HYPHEN-MINUS

SPECIAL = re.compile('([' + re.escape('<>[]()!₀₁₂₃₄₅₆₇₈₉') + '])')

SUPERSCRIPT = {
    '+': '⁺', '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
    '−': '⁻', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
}

SUBSCRIPT = {
    '+': '₊', '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
    '−': '₋', '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',
}

SKIPELEM = {
    '₁': 'em-sp',  '₂': 'en-sp',  '₃': 'sp-3', '₄': 'sp-4',
    '₅': 'sp-5',   '₆': 'sp-6',   '₇': 'sp-7', '₈': 'sp-8',
}

# https://www.desmos.com/calculator/jirjvadckz
#
#    name    size   class
#    ────  ───────  ─────
# ₁  em      1  em    em
# ₂  en     1/2 em    en
# ₃         1/3 em   ws3
# ₄  word   1/4 em   ws4
# ₅  thin   1/6 em   ws5
# ₆  hair  1/10 em   ws6
# ₇        1/16 em   ws7
# ₈        1/24 em   ws8

def _parse(
    src    : str,
    offset : int           = 0,
    stop   : Optional[str] = None,
    italic : bool          = False
) -> tuple[list[str | HtmlElement], int, bool]:
    # Returns HTML output, the index following the last character parsed,
    #   and whether the parse ended because the stop pattern was matched.
    #  (If the stop pattern is matched, the returned index is the index
    #   following the stop pattern.)
    #
    # hyperlinks               @{...}{...}
    # inline math               $...$
    # inline code               `...`
    # small capitals    %word  %{...}
    # variables         'letr  '{...}
    # superscripts      ^nmrl  ^{...}
    # subscripts        _nmrl  _{...}
    # italic            *word  *{...}
    # bold                     &{...}
    # margin notes             †{...}
    # inline notes            ※ {...}
    # no-break spans            {...}
    # fixed whitespace  ₁₂₃₄₅₆₇₈₉
    # hyphenation point ₀

    # offset        # number of characters scanned
    adv = offset    # number of characters taken (less than or equal to offset)
    out = []        # output for the slice src[:adv]
    stopped = False

    def emit(text):
        fragment = []
        for char in SPECIAL.split(text):
            if not char:
                continue
            match char:
                case '<':
                    fragment.append('&lt;')
                case '>':
                    fragment.append('&gt;')
                case '('|')'|'['|']' if italic:
                    if fragment:
                        out.append(''.join(fragment))
                        fragment = []
                    out.append(HtmlElement('esc-i', char))
                case '!' if not italic:
                    if fragment:
                        out.append(''.join(fragment))
                        fragment = []
                    out.append(HtmlElement('i', char))
                case '₀':
                    fragment.append('&shy;')
                case '₁'|'₂'|'₃'|'₄'|'₅'|'₆'|'₇'|'₈'|'₉':
                    if fragment:
                        out.append(''.join(fragment))
                        fragment = []
                    out.append(HtmlElement(SKIPELEM[char], ' '))
                case _:
                    fragment.append(char)
        if fragment:
            out.append(''.join(fragment))

    ini = None  # index of the sigil being examined

    def push(post, *expansion):
        # post        index of the first character after the delimited region
        # expansion   list of str/HtmlElement
        nonlocal offset
        nonlocal adv
        if ini > adv:
            emit(src[adv:ini])
        out.extend(expansion)
        offset = post
        adv = post

    length = len(src)
    while offset < length:
        sigil = INITIAL.search(src, offset)

        # There are no more sigils that could start a delimited region,
        #   so there can’t be any more delimited regions, so we tidy up
        #   and exit the loop.
        if sigil is None:
            # Only read up until the stop pattern.
            if stop is not None:
                cutoff = src.find(stop, offset)
                if cutoff != -1:
                    if cutoff > adv:
                        emit(src[adv:cutoff])
                        adv = cutoff
                    adv += len(stop)
                    stopped = True
                    break
            # Otherwise read to the end of the source.
            if adv < len(src):
                emit(src[adv:])
                adv = len(src)
            break

        # Check whether the stop pattern occurs at or before the next sigil.
        ini = sigil.start()
        if stop is not None:
            cutoff = src.find(stop, offset, ini + len(stop))
            if cutoff != -1:
                if cutoff > adv:
                    emit(src[adv:cutoff])
                    adv = cutoff
                adv += len(stop)
                stopped = True
                break

        # At the very least, the offset should be the index after the sigil.
        # If this is a valid entity, we will move it further (to the end of
        #   the entity).
        offset = sigil.end()

        match sigil.group():
            # HTML
            case '<':
                # Comment
                if src[offset:offset+3] == '!--':
                    offset += 3
                    end = src.find('-->', offset)
                    if end == -1:
                        push(offset, parse_error('&lt;!--'))
                    else:
                        push(end + 3)
                    continue

                # Unexpected closing tag
                #   (Note that we’re overly restrictive here.)
                if src[offset:offset+1] == '/':
                    offset += 1
                    push(offset, parse_error('&lt;/'))
                    continue

                # Less-than operator
                if not ELEMINI.fullmatch(src[offset:offset+1]):
                    continue

                # Plausible opening tag
                index = offset
                element = None
                attrs = {}

                # 1 Find the closing delimiter
                while True:
                    match = TAGBRK.search(src, index)
                    if match is None:
                        break
                    index = match.start()
                    char = match.group()
                    if char == '>':
                        tag = src[offset:index].removesuffix('/') \
                            .split(maxsplit=1)
                        index += 1
                        element = tag[0]
                        if len(tag) > 1:
                            attrs = parse_attributes(tag[1])
                        break
                    if char == '"' or char == "'":
                        index += 1
                        delim = src.find(char, index)
                        if delim == -1:
                            err = parse_error('&lt;' + src[offset:index])
                            push(index, err)
                            break
                        index = delim + 1
                        continue
                    raise AssertionError
                else:
                    push(offset, parse_error('&lt;'))
                    continue

                if element is None:
                    continue

                # 2 Check that the opening tag is well-formed
                if not (element in ELEMENTS or CUSTOM.fullmatch(element)):
                    # This isn’t an HTML tag, although it looks like one.
                    #   We’re a little more strict than we need to be; see
                    #   https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
                    push(index, parse_error(f'&lt;{src[offset:index-1]}&gt;'))
                    continue

                if attrs is None:
                    # The attributes are not well-formed.
                    push(index, parse_error(f'&lt;{src[offset:index-1]}&gt;'))
                    continue

                # 3 Find the closing tag
                if element in VOID:
                    # This is a void element, so there’s
                    #   no corresponding closing tag.
                    if element == 'include':
                        if 'href' not in attrs:
                            push(index)
                            continue
                        location = resolve_include(attrs['href'])
                        if location is None:
                            push(index)
                            continue
                        with open(location) as external:
                            content = external.read()
                        _, extension = path.splitext(attrs['href'])
                        if extension == '.css':
                            INLINESTYLES.append(content)
                            push(index)
                            continue
                        if extension == '.py':
                            GLOBALS['STREAM'] = out
                            exec(content, GLOBALS)
                            push(index)
                            continue
                        inner, _, _ = _parse(content.strip())
                        push(index, *inner)
                    elif element == 'module':
                        MODULES.update(attrs)
                        push(index)
                    else:
                        push(index, HtmlElement(element, **attrs))
                    continue

                special = element in ('style', 'python')
                if special:
                    cutoff = src.find('</', index)
                    complete = cutoff != -1
                    if complete:
                        inner = src[index:cutoff]
                        post = cutoff + 2
                else:
                    inner_italic = italic or element == 'i' \
                        or ('class' in attrs and 'i' in attrs['class'].split())
                    inner, post, complete = \
                        _parse(src, index, '</', inner_italic)

                if not complete:
                    push(index, parse_error(f'&lt;{src[offset:index-1]}&gt;'))
                    continue

                # 4 Check that the closing tag matches
                end = src.find('>', post)
                if end == -1:
                    interior = f'&lt;{element}&gt;...' if special \
                        else HtmlElement(element, *inner, **attrs)
                    push(post, interior, parse_error(f'&lt;/'))
                    continue

                tag = src[post:end]
                if tag.strip() != element:
                    interior = f'&lt;{element}&gt;...' if special \
                        else HtmlElement(element, *inner, **attrs)
                    push(end + 1, interior, parse_error(f'&lt;/{tag}&gt;'))
                    continue

                if element == 'style':
                    INLINESTYLES.append(inner)
                    push(end + 1)
                    continue

                if element == 'python':
                    push(end + 1)
                    GLOBALS['STREAM'] = out
                    exec(unindent(inner), GLOBALS)
                    continue

                push(end + 1, HtmlElement(element, *inner, **attrs))

            # Hyperlinks
            case '@':
                if src[offset:offset+1] != '{':
                    continue
                offset += 1
                inner, post, complete = _parse(src, offset, '}', italic)
                if not complete:
                    push(offset, parse_error('@{'))
                    continue
                delim = NONSPACE.search(src, post)
                if delim is None:
                    push(post, parse_error(inner))
                    continue
                if delim.group() != '{':
                    push(delim.end(), *inner, parse_error(delim.group()))
                    continue
                start = delim.end()
                end = src.find('}', start)
                if end == -1:
                    push(start, *inner, parse_error('{'))
                    continue
                url = src[start:end].strip()
                if '{' in url or '"' in url or "'" in url:
                    push(end + 1, *inner, parse_error(url))
                else:
                    push(end + 1, HtmlElement('a', *inner, href=url))

            # Inline mathematics
            case '$':
                end = src.find('$', offset)
                if end == -1:
                    push(offset, parse_error('$'))
                else:
                    expr = src[offset:end]
                    block = expr[:1] == '#'
                    if block: expr = expr[1:]
                    math = parse_math(expr)
                    if math is None:
                        push(end + 1, parse_error(f'${src[offset:end]}$'))
                    elif block:
                        push(end + 1, math.html(inline=False))
                    else:
                        inner = math.html(inline=True)
                        push(end + 1, HtmlElement('inline-math', inner))

            # Inline code
            case '`':
                # TODO use _parse
                end = src.find('`', offset)
                if end == -1:
                    push(offset, parse_error('`'))
                else:
                    push(end + 1, HtmlElement('code', src[offset:end]))

            # Small capitals
            case '%':
                if src[offset:offset+1] == '{':
                    offset += 1
                    inner, post, complete = _parse(src, offset, '}', italic)
                    if complete:
                        push(post, HtmlElement('small-caps', *inner))
                    else:
                        push(offset, parse_error('%{'))
                else:
                    word = WORD.match(src, offset)
                    if word is None:
                        continue
                    span = HtmlElement('small-caps', word.group())
                    push(word.end(), span)

            # Variables
            case "'":
                if src[offset:offset+1] == '{':
                    offset += 1
                    inner, post, complete = _parse(src, offset, '}', italic)
                    if complete:
                        push(post, HtmlElement('var', *inner))
                    else:
                        push(offset, parse_error("'{"))
                else:
                    letter = LETTER.match(src, offset)
                    if letter is None:
                        continue
                    push(letter.end(), HtmlElement('var', letter.group()))

            # Superscripts and subscripts
            case '^' | '_':
                if src[offset:offset+1] == '{':
                    offset += 1
                    inner, post, complete = _parse(src, offset, '}', italic)
                    if complete:
                        element = 'sub' if sigil.group() == '_' else 'sup'
                        push(post, HtmlElement(element, *inner))
                    else:
                        push(offset, parse_error(sigil.group() + "{"))
                else:
                    numeral = NUMERAL.match(src, offset)
                    if numeral is None:
                        continue
                    charmap = SUBSCRIPT if sigil.group() == '_' else SUPERSCRIPT
                    replacement = ''.join(charmap[d] for d in numeral.group())
                    push(numeral.end(), replacement)

            # Italic
            case '*':
                if src[offset:offset+1] == '{':
                    offset += 1
                    inner, post, complete = _parse(src, offset, '}', True)
                    if complete:
                        push(post, HtmlElement('i', *inner))
                    else:
                        push(offset, parse_error('*{'))
                else:
                    word = WORD.match(src, offset)
                    if word is None:
                        continue
                    push(word.end(), HtmlElement('i', word.group()))

            # Bold
            case '&':
                if src[offset:offset+1] != '{':
                    continue
                offset += 1
                inner, post, complete = _parse(src, offset, '}', italic)
                if complete:
                    push(post, HtmlElement('b', *inner))
                else:
                    push(offset, parse_error('&{'))

            # Margin notes
            case '†':
                if src[offset:offset+1] != '{':
                    continue
                offset += 1
                inner, post, complete = _parse(src, offset, '}', italic)
                if complete:
                    push(post, HtmlElement('margin-note', *inner))
                else:
                    push(offset, parse_error('†{'))

            # Inline notes
            case '※':
                if src[offset:offset+2] == ' {':
                    offset += 2
                elif src[offset:offset+1] == '{':
                    offset += 1
                else:
                    continue
                inner, post, complete = _parse(src, offset, '}', italic)
                if complete:
                    push(post, HtmlElement('inline-note', *inner))
                else:
                    push(offset, parse_error(src[ini:offset]))

            # No-break spans
            case '{':
                inner, post, complete = _parse(src, offset, '}', italic)
                if complete:
                    push(post, HtmlElement('no-break', *inner))
                else:
                    push(offset, parse_error('{'))

            case '}':
                push(offset, parse_error('}'))

    return (out, adv, stopped)


def parse(src : str) -> list[str | HtmlElement]:
    out, _, _ = _parse(src)
    return out


# Compiling  · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·


def _tagpair(
    element : str,
    gap_a : bool,
    gap_b : bool,
    _id   : Optional[str] = None,
    _class: Optional[str] = None,
) -> tuple[str, str]:
    opening = [element]
    if _id is not None:
        opening.append(f'id="{_id}"')
    classes = []
    if _class: classes.append(_class)
    if gap_a: classes.append('gap-top')     # gap-top
    if gap_b: classes.append('gap-bottom')  # gap-bottom
    if classes:
        classes = " ".join(classes)
        opening.append(f'class="{classes}"')
    opening = " ".join(opening)
    return (f'<{opening}>', f'</{element}>')


def _head(output : list[str], lines : list[str], gap_a : bool, gap_b : bool):
    level, anchor, text = lines
    opening, closing = _tagpair(f'h{level}', gap_a, gap_b, _id=anchor)
    if anchor is not None:
        permalink = PERMALINK[int(level)]
        if permalink is not None:
            text = f'<a href="#{anchor}">{permalink}</a> {text}'
    output.append(f'{opening}{text}{closing}')


def _para(output : list[str], lines : list[str], gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('p', gap_a, gap_b)
    output.append(opening)
    output.extend(lines)
    output.append(closing)


def _note(output : list[str], lines : list[str], meta, gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('block-note', gap_a, gap_b, _class=meta)
    output.append(opening)
    output.extend(_preprocess(lines))
    output.append(closing)


def _quot(output : list[str], lines : list[str], gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('block-quote', gap_a, gap_b)
    output.append(opening)
    output.extend(_preprocess(lines))
    output.append(closing)


def _iden(output : list[str], lines : list[str], gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('block-indent', gap_a, gap_b)
    output.append(opening)
    output.extend(_preprocess(lines))
    output.append(closing)


def _list(output : list[str], items : list[list[str]], gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('ul', gap_a, gap_b)
    output.append(opening)
    for item in items:
        output.append('<li>')
        output.extend(_preprocess(item))
        output.append('</li>')
    output.append(closing)


def _code(output : list[str], lines : list[str], meta, gap_a : bool, gap_b : bool):
    if meta and (lang := meta[0]) in HANDLERS:
        modifiers = meta[1:] or None
        lines = HANDLERS[lang](lang, lines, modifiers=modifiers)
    opening, closing = _tagpair('block-code', gap_a, gap_b)
    output.append(opening + '<pre>')
    output.extend(lines)
    output.append('</pre>' + closing)


def _math(output : list[str], lines : list[str], meta, gap_a : bool, gap_b : bool):
    opening, closing = _tagpair('block-math', gap_a, gap_b, _class=meta)
    output.append(opening + '$#')
    output.extend(lines)
    output.append('$' + closing)


SIGIL = {
    '*': 'note',
    '†': 'note',
    '"': 'quot',
    '>': 'iden',
    '•': 'list',
    '#': 'code',
}

INSET = set(SIGIL.values())

ANCHOR = '([a-zA-Z0-9_-]+)'
HEADING = re.compile(f'#([123456]) +(?:\\[{ANCHOR}\\] +)?')

def _preprocess(src : list[str], enclose : bool = False) -> list[str]:
    # Returns lines of hybrid text.
    #
    # head  #2 Second-level Heading
    #
    #       #3 [anchor] Third-level Heading
    #
    # note  * block note
    #         spanning multiple lines
    #
    # quot  " block quote
    #         spanning multiple lines
    #
    # iden  > indented block
    #         spanning multiple lines
    #         > containing a
    #           nested block
    #
    # list  • first list item
    #         spanning multiple lines
    #       • second list item
    #         • with a nested list
    #
    # code  # lang
    #         code block
    #         spanning multiple lines
    #
    #       # begin
    #       code block
    #       spanning multiple lines
    #       # end
    #
    #       # begin lang
    #       code block
    #       spanning multiple lines
    #       # end
    #
    # math  $^ centered MathML block $
    #
    #       $> left-aligned and indented MathML block $

    # This is a list of "gap" or ("head", [level, anchor, text], None)
    # or ("kind", [line, ...], meta) triples where kind is one of the
    # following: para, note, quot, iden, list, code verb, or math.
    blocks = []

    block_kind  = None
    block_lines = []
    block_meta  = None
    offset      = None

    def finish():
        nonlocal block_kind, block_lines, block_meta, offset
        if block_kind is None:
            return
        if not block_lines:
            block_kind = None
            block_meta = None
            offset     = None
            return
        gap = False
        while block_lines and not block_lines[-1]:
            block_lines.pop()
            gap = True
        blocks.append((block_kind, block_lines, block_meta))
        if gap:
            blocks.append('gap')
        block_kind  = None
        block_lines = []
        block_meta  = None
        offset      = None

    todo = list(reversed(src))

    while todo:
        line = todo.pop()
        trimmed = line.strip()

        if not trimmed:
            if block_kind == 'para':
                finish()
                blocks.append('gap')
            elif block_kind is None:
                blocks.append('gap')
            elif block_lines:
                block_lines.append('')
            continue

        # INVARIANT trimmed is now nonempty

        if block_kind == 'verb':
            if trimmed[0] == '#' and trimmed[1:].lstrip().lower() == 'end':
                finish()
            else:
                block_lines.append(line)
            continue

        if block_kind == 'math':
            if '$' not in trimmed:
                block_lines.append(line)
                continue
            start = line.index('$')
            pre = line[:start]
            post = line[start+1:]
            if pre.strip():
                block_lines.append(pre)
            finish()
            if post.strip():
                todo.append(post)
            continue

        if trimmed.startswith('//'):
            # In addition to <!-- HTML --> style comments, we also support
            #   single-line comments with virgules (at the start of a line).
            continue

        # INVARIANT block_kind is now None, "para", or
        #   "note", "quot", "iden", "list", or "code".

        indent = len(line) - len(line.lstrip())

        if block_kind in INSET:
            if indent >= offset:
                block_lines.append(line[offset:])
                continue
            finish()

        # INVARIANT block_kind is now None or "para".

        char = trimmed[0]
        if char in SIGIL:

            if char == '#':
                match = HEADING.match(trimmed)
                if match:
                    finish()
                    level  = match.group(1)
                    anchor = match.group(2)
                    text   = trimmed[match.end():]
                    blocks.append(('head', [level, anchor, text], None))
                    continue

            content = trimmed[1:].lstrip()
            overhang = len(trimmed) - len(content)
            if overhang > 1:
                finish()
                offset = indent + overhang

                if char == '#':
                    mods = [mod.lower() for mod in content.split()]
                    if mods[0] == 'begin':
                        block_kind = 'verb'
                        block_meta = mods[1:]
                    else:
                        block_kind = 'code'
                        block_meta = mods
                    continue

                block_kind = SIGIL[char]
                block_lines.append(content)
                if char == '*':
                    block_meta = 'i'
                continue

        # INVARIANT block_kind is still None or "para".

        if '$' in trimmed:
            s0 = trimmed.find('$^')
            s1 = trimmed.find('$>')
            match s0, s1:
                case -1, -1: start = None
                case  _, -1: start = s0
                case -1,  _: start = s1
                case  _,  _: start = min(s0, s1)
            if start is not None:
                pre = line[:start]
                post = line[start+2:]
                if pre.strip():
                    block_kind = 'para'
                    block_lines.append(pre)
                finish()
                block_kind = 'math'
                block_meta = 'left' if line[start+1] == '>' else 'center'
                if post.strip():
                    todo.append(post)
                continue

        # INVARIANT block_kind is still None or "para".

        block_kind = 'para'
        block_lines.append(line)

    finish()

    # Before iterating over the blocks, we deduplicate gaps
    #   and gather list items into lists.

    filtered = []
    gap = False
    prev_kind = None
    active_list = None
    for item in blocks:
        if item == 'gap':
            gap = True
            continue
        kind, lines, _ = item
        if kind == 'list':
            if prev_kind == 'list':
                active_list.append(lines)
                gap = False
                continue
            if gap and filtered:
                filtered.append('gap')
            active_list = [lines]
            filtered.append(('list', active_list, None))
        else:
            if kind == 'para' and prev_kind == 'para':
                enclose = True
            if gap and filtered:
                filtered.append('gap')
            filtered.append(item)
        prev_kind = kind
        gap = False

    blocks = filtered

    # Now we can finally transform each block!

    output = []
    L = len(blocks) - 1
    for index, item in enumerate(blocks):
        if item == 'gap':
            continue
        gap_above = index > 0 and blocks[index-1] == 'gap'
        gap_below = index < L and blocks[index+1] == 'gap'
        kind, lines, meta = item
        match kind:
            case 'para':
                if enclose:
                    _para(output, lines, gap_above, gap_below)
                else:
                    output.extend(lines)
            case 'head': _head(output, lines,       gap_above, gap_below)
            case 'note': _note(output, lines, meta, gap_above, gap_below)
            case 'quot': _quot(output, lines,       gap_above, gap_below)
            case 'iden': _iden(output, lines,       gap_above, gap_below)
            case 'list': _list(output, lines,       gap_above, gap_below)
            case 'code': _code(output, lines, meta, gap_above, gap_below)
            case 'verb': _code(output, lines, meta, gap_above, gap_below)
            case 'math': _math(output, lines, meta, gap_above, gap_below)

    return output


def compile(src : str) -> list[str | HtmlElement]:
    lines = _preprocess(src.splitlines(), enclose=True)
    return parse('\n'.join(lines))


# Globals  · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·


# Available for python elements. Routines can emit HTML by appending to STREAM.
GLOBALS = {
    'HtmlElement':  HtmlElement,
    'parse_css':    parse_css,
    'parse_math':   parse_math,
    'parse_text':   parse,
    'compile':      compile,
    'PERMALINK':    PERMALINK,
    'HANDLERS':     HANDLERS,
    'INLINESTYLES': INLINESTYLES,
    'MODULES':      MODULES,
    'STREAM':       None
}


# Main · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·

if __name__ == '__main__':
    from sys import exit, stderr

    args = argv[1:]
    if not args or '-h' in args or '--help' in args:
        print(f'usage: {argv[0]} <title> <input> <output>')
        exit()
    args = list(reversed(args))

    icon = None
    title = None
    link = []
    inp = None
    out = None
    while len(args) > 0:
        arg = args.pop()
        match arg:
            case '-i' | '--icon':
                icon = args.pop()
            case '-t' | '--title':
                title = args.pop()
            case '-l' | '--link':
                link.append(args.pop())
            case _ if inp is None:
                inp = arg
            case _ if out is None:
                out = arg
            case _:
                raise AssertionError(f'unknown argument "{arg}"')

    if inp is None:
        raise AssertionError(f'missing source path')
    if out is None:
        raise AssertionError(f'missing destination path')

    SOURCE_DIR = path.dirname(path.abspath(inp))

    # Head - - - - - - - - - - - - - - -

    MIME = {
        '.gif':  'gif',
        '.jpeg': 'jpeg',
        '.jpg':  'jpeg',
        '.png':  'png',
        '.svg':  'svg+xml',
        '.webp': 'webp',
    }

    head = []

    if title is not None:
        head.append(f'<title>{title}</title>')

    if icon is not None:
        _, extension = path.splitext(icon)
        mime = MIME[extension]
        head.append(f'<link rel="icon" href="{icon}" type="image/{mime}">')

    for url in link:
        _, extension = path.splitext(icon)
        if extension != '.css':
            raise AssertionError()
        head.append(f'<link rel="stylesheet" href="{url}" type="image/css">')

    # HTML - - - - - - - - - - - - - - -

    with open(inp) as fh:
        src = fh.read()
    content = compile(src)
    body = HtmlElement('div',
        HtmlElement('div',
            *content,
            name='chase'
        ),
        name='galley'
    )
    body.prune()
    elements, classes = extant(body)
    html = render_html(body)

    # Modules  - - - - - - - - - - - - -

    modules = set()

    def _add(mod):
        if mod in modules:
            return
        modules.add(mod)
        if mod in DEPENDENCIES:
            for dep in DEPENDENCIES[mod]:
                _add(dep)

    for mod in MODULES:
        _add(mod)

    if 'math' in elements:
        _add('math')

    modules = [
        fname for _, fname in
        sorted(
            AVAILABLEMODULES[mod]
            for mod in modules
            if AVAILABLEMODULES[mod] is not None
        )
    ]

    # CSS  - - - - - - - - - - - - - - -

    stylesheet = StyleSheet()

    for mod in modules:
        with open(mod) as fh:
            src = fh.read()
        parse_css(src, stylesheet)

    for src in INLINESTYLES:
        parse_css(src, stylesheet)

    css = render_css(stylesheet, depth=1)

    # Output - - - - - - - - - - - - - -

    page = '\n'.join([
        '<!DOCTYPE html>',
        '<meta charset="utf-8">',
        '<meta name="viewport"'
            ' content="width=device-width,'
            ' height=device-height,'
            ' initial-scale=1.0">',
        *head,
        '<style>',
        css,
        '</style>',
        html
    ])

    with open(out, 'w') as fh:
        print(page, file=fh)
