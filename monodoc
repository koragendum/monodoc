#! /usr/bin/python

import mathml
import re
from re import Match as MatchObject
from typing import Optional

INDENTSIZE = 1.0    # size of each indent step in em
PERMALINK = '#'

PRERENDERFILTER  = None
MIDRENDERFILTER  = None
POSTRENDERFILTER = None
CODEBLOCKFILTER  = None
CODEBLOCKCLASS   = None

# See guide.md and guide.html for a description of the supported features.

ELEMENTS = {
    # HTML - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    'html'       , 'base'       , 'head'       , 'link'       , 'meta'       ,
    'style'      , 'title'      , 'body'       , 'address'    , 'article'    ,
    'aside'      , 'footer'     , 'header'     , 'h1'         , 'h2'         ,
    'h3'         , 'h4'         , 'h5'         , 'h6'         , 'hgroup'     ,
    'main'       , 'nav'        , 'section'    , 'search'     , 'blockquote' ,
    'dd'         , 'div'        , 'dl'         , 'dt'         , 'figcaption' ,
    'figure'     , 'hr'         , 'li'         , 'menu'       , 'ol'         ,
    'p'          , 'pre'        , 'ul'         , 'a'          , 'abbr'       ,
    'b'          , 'bdi'        , 'bdo'        , 'br'         , 'cite'       ,
    'code'       , 'data'       , 'dfn'        , 'em'         , 'i'          ,
    'kbd'        , 'mark'       , 'q'          , 'rp'         , 'rt'         ,
    'ruby'       , 's'          , 'samp'       , 'small'      , 'span'       ,
    'strong'     , 'sub'        , 'sup'        , 'time'       , 'u'          ,
    'var'        , 'wbr'        , 'area'       , 'audio'      , 'img'        ,
    'map'        , 'track'      , 'video'      , 'embed'      , 'fencedframe',
    'iframe'     , 'object'     , 'picture'    , 'portal'     , 'source'     ,
    'svg'        , 'math'       , 'canvas'     , 'noscript'   , 'script'     ,
    'del'        , 'ins'        , 'caption'    , 'col'        , 'colgroup'   ,
    'table'      , 'tbody'      , 'td'         , 'tfoot'      , 'th'         ,
    'thead'      , 'tr'         , 'button'     , 'datalist'   , 'fieldset'   ,
    'form'       , 'input'      , 'label'      , 'legend'     , 'meter'      ,
    'optgroup'   , 'option'     , 'output'     , 'progress'   , 'select'     ,
    'textarea'   , 'details'    , 'dialog'     , 'summary'    , 'slot'       ,
    'template'   ,
    # MathML - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    'math'       , 'mfrac'      , 'mi'         , 'mn'         , 'mo'         ,
    'mover'      , 'mroot'      , 'mrow'       , 'mspace'     , 'msqrt'      ,
    'msub'       , 'msubsup'    , 'msup'       , 'mtext'      , 'munder'     ,
    'munderover' ,
    # Extensions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    'python'     ,
}

BREAKING = {
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'pre', 'div', 'p', 'ol', 'ul', 'table',
    'details'
}


ATTRKEY = re.compile('[a-zA-Z](?:-?[a-zA-Z0-9]+)*')
ATTRBRK = re.compile('[\\s=\'"]')

def parseattrs(text : str) -> Optional[dict[str, str]]:
    # We assume there is no leading whitespace,
    #   and maintain that property as an invariant.
    if len(text) == 0: return {}
    parts = []
    while True:
        match = ATTRBRK.search(text)
        if match is None:
            parts.append(text)
            break
        item = text[:match.start()]
        if item:
            parts.append(item)
        char = match[0]
        if char == '=':
            parts.append(None)
            text = text[match.end():].lstrip()
            if text: continue
            break
        if char in ('"', "'"):
            left = match.end()
            try: right = text.index(char, left)
            except ValueError: return None
            parts.append(text[left:right])
            text = text[right+1:].lstrip()
            if text: continue
            break
        text = text[match.end():].lstrip()
        if text: continue
        break
    attrs = {}
    index = 0
    length = len(parts)
    while index < length:
        key = parts[index]
        if key is None: return None # “= ...”
        if not ATTRKEY.fullmatch(key): return None
        if index + 2 < length and parts[index+1] is None:
            value = parts[index+2]
            if value is None: return None # “key = = ...”
            attrs[key] = value
            index += 3
        else:
            attrs[key] = None
            index += 1
    return attrs


def parsetag(text : str, offset : int = 0) -> Optional[tuple[str, str, str, int, int]]:
    # Returns a quintuple of
    #   – 'open' or 'close'
    #   – the element name
    #   – the tag attributes
    #   – the index of the start of the tag
    #   – the index of the start of the remainder
    # or None if no tag was found.
    #
    # That is,
    #   – text[   :tag] is the text before the first tag
    #   – text[tag:rem] is the text of the first tag verbatim
    #   – text[rem:   ] is the text following the first tag
    #
    # Note that the text following the tag may (or may not) include
    #   – any corresponding closing tag
    #   – the contents of the HTML element created by the tag
    #   – the contents of any HTML element (as for "<br>")
    #   – additional text after the HTML element
    while True:
        try:
            start = text.index('<', offset)
        except ValueError:
            return None
        index = start + 1
        length = len(text)

        # Closing tags don’t include attributes,
        #   so this case is straightforward.
        if index < length and text[index] == '/':
            try:
                end = text.index('>', start+2)
            except ValueError:
                offset += 1
                continue
            name = text[start+2:end].strip()
            if name not in ELEMENTS:
                # This isn’t an HTML tag,
                #   although it looks like one.
                offset += 1
                continue
            return ('close', name, '', start, end+1)

        # Opening tags might include attributes, and
        #   in particular, may contain quoted text.
        while index < length:
            char = text[index]
            if char in ("'", '"'):
                try:
                    delim = text.index(char, index+1)
                except ValueError:
                    break
                index = delim + 1
                continue
            if char == '<':
                break
            if char == '>':
                parts = text[start+1:index].split(maxsplit=1)
                if len(parts) == 0:
                    break
                name = parts[0]
                if name not in ELEMENTS:
                    # This isn’t an HTML tag,
                    #   although it looks like one.
                    break
                attrs = (parts[1] if len(parts) > 1 else '')
                return ('open', name, attrs, start, index+1)
            index += 1

        # This “<” isn’t the start of a valid opening
        #   tag, so skip over it and check again.
        offset += 1


def tagpair(
    element : str,
    ga : bool,
    gb : bool,
    classes : Optional[str | list[str]] = None,
    name  : Optional[str] = None,
    style : Optional[str] = None,
) -> tuple[str, str]:
    # ga = gap above
    # gb = gap below
    opening = [element]
    if name is not None:
        opening.append(f'id="{name}"')
    if classes is None:
        classes = []
    elif isinstance(classes, list):
        classes = [*classes]
    else:
        classes = [classes]
    if ga: classes.append('gt') # top
    if gb: classes.append('gb') # bottom
    if len(classes) > 0:
        classes = " ".join(classes)
        opening.append(f'class="{classes}"')
    if style is not None:
        opening.append(f'style="{style}"')
    opening = " ".join(opening)
    return (f'<{opening}>', f'</{element}>')


ESCAPE = {
    r'\\': '&#x5C;',
    r'\&': '&amp;',
    r'\#': '&num;',
    r'\*': '&ast;',
    r'\_': '&#x5F;',
    r'\|': '&#x7C;',
    r'\^': '&#x5E;',
    r'\%': '&#x25;',
    r'\+': '&plus;',
    r'\−': '&minus;',
    r'\×': '&times;',
    r'\–': '&ndash;'
}

# This matches [$a]($b) where $a is any sequences of characters that aren't
#   brackets and $b is any sequence of characters that aren't parentheses.
HYPERLINK = re.compile(r'\[([^\[\]]+?)\]\(([^()]+?)\)')

SMALLCAPS = re.compile(r'%([a-zA-Zα-ωΑ-Ω\-]+|\{[^{}]+?\})')

VARIABLE = re.compile('@[a-zA-Zα-ωΑ-Ω]+')

SCRIPT = re.compile(r'(?<=\S)(\^|_|__)(\d+|\uf004?\uf005\uf004?|\{[^{}]*\})')

CONTEXTWS = re.compile('([' + re.escape('()[]+−×÷⋅') + '])')

letr = '([a-zA-Zα-ωΑ-Ω0-9\uf004\uf005])'
mark = '[\uf002\uf003\uf006]'
RLETR = re.compile(letr + '(?:\uf009'+mark+')*$')
LLETR = re.compile('^(?:'+mark+'\uf008)*' + letr)

rchar = '([a-zA-Zα-ωΑ-Ω0-9\uf004\uf005' + re.escape(')]') + '])'
lchar = '([a-zA-Zα-ωΑ-Ω0-9\uf004\uf005' + re.escape('([') + '])'
RCHAR = re.compile(rchar + '(?:\uf009'+mark+')*$')
LCHAR = re.compile('^(?:'+mark+'\uf008)*' + lchar)

# This matches a single underscore or any number of asterisks, or
#   the Unicode scalar values that start or end a formatting context.
FORMATTER = re.compile(r'_|\*+|\uf008|\uf009')


def replacelist(text : str, sentinel : str, replacements : list[str]) -> str:
    # NOTE sentinel must be a single character
    # TODO use re.sub instead
    offset, parts = 0, []
    for r in replacements:
        index = text.index(sentinel, offset)
        if offset < index:
            parts.append(text[offset:index])
        parts.append(r)
        offset = index+1
    if offset < len(text):
        rem = text[offset:]
        assert sentinel not in rem
        parts.append(rem)
    return ''.join(parts)


def render(text : str, escape : bool = True) -> str:
    # This routine is responsible for inline styling, including
    #   inline code, links, substitutions, italic, and bold.

    # TODO regions with breaking discouraged
    #   <span style="display: inline-block;">

    # Step 0. Custom Transformations

    if PRERENDERFILTER is not None:
        text = PRERENDERFILTER(text)

    # Step 1. Escape Sequences

    if escape:
        # TODO use re.sub instead
        if r'\<' in text:
            text = text.replace(r'\<', '&lt;')
        if r'\>' in text:
            text = text.replace(r'\>', '&gt;')

    # Step 2. Ensure we don't disrupt HTML tags

    tags = []
    next_tag = parsetag(text)
    if next_tag is not None:
        offset, parts = 0, []
        while next_tag is not None:
            _, _, _, tag_start, rem_start = next_tag
            if offset < tag_start:
                parts.append(text[offset:tag_start])
            parts.append('\uf000')
            tags.append(text[tag_start:rem_start])
            offset = rem_start
            next_tag = parsetag(text, offset)
        if offset < len(text):
            parts.append(text[offset:])
        text = ''.join(parts)

    # Step 3a. Inline code

    if r'\`' in text:
        text = text.replace(r'\`', '&#x60;')

    code = []
    try: code_start = text.index('`')
    except ValueError: code_start = None
    if code_start is not None:
        offset, parts = 0, []
        while code_start is not None:
            if offset < code_start:
                parts.append(text[offset:code_start])
            try: code_end = text.index('`', code_start+1)
            except ValueError:
                parts.append('\uf001')
                code.append(text[code_start+1:])
                offset = len(text)
                break
            parts.append('\uf001')
            code.append(text[code_start+1:code_end])
            offset = code_end+1
            try: code_start = text.index('`', offset)
            except ValueError: code_start = None
        if offset < len(text):
            parts.append(text[offset:])
        text = ''.join(parts)
        code = [f'<code>{s}</code>' for s in code]

    # Step 3b. Inline mathematical text

    if r'\$' in text:
        text = text.replace(r'\$', '&#x24;')

    math = []
    try: math_start = text.index('$')
    except ValueError: math_start = None
    if math_start is not None:
        offset, parts = 0, []
        while math_start is not None:
            if offset <  math_start:
                parts.append(text[offset:math_start])
            try: math_end = text.index('$', math_start+1)
            except ValueError:
                parts.append('\uf00a')
                math.append(text[math_start+1:])
                offset = len(text)
                break
            parts.append('\uf00a')
            math.append(text[math_start+1:math_end])
            offset = math_end+1
            try: math_start = text.index('$', offset)
            except ValueError: math_start = None
        if offset < len(text):
            parts.append(text[offset:])
        text = ''.join(parts)
        def mrender(expr):
            result = mathml.parse(expr)
            if result is None:
                return f'<code>{expr}</code>'
            return '\n'.join(mathml.render(result, True))
        math = [mrender(expr) for expr in math]

    # Step 3c. Escape Sequences

    # TODO use re.sub instead
    for pattern, replacement in ESCAPE.items():
        if pattern in text:
            text = text.replace(pattern, replacement)

    # Step 4. Hyperlinks
    #   These have the form [displayed](url) with any amount of space in the
    #     brackets or in the parentheses.
    #   NOTE we ought to actually parse the text and match delimiters properly,
    #     but we assume cases where the displayed markdown or HTML includes
    #     brackets or the URL includes parentheses are rare enough that we can
    #     ask users to type out the HTML by hand.

    lnks = []
    def linkreplacement(match : MatchObject) -> str:
        displayed, url = match[1], match[2]
        lnks.append(f'<a href="{url}">')
        lnks.append('</a>')
        return f'\uf002\uf008{displayed}\uf009\uf002'
    text = HYPERLINK.sub(linkreplacement, text)

    # Step 5. Small Capitals

    smcp = []
    def smcpreplacement(match : MatchObject) -> str:
        content = match[1]
        if content[0] == '{':
            content = content[1:-1].strip()
        smcp.append(f'<span class="sc">')
        smcp.append('</span>')
        return f'\uf003\uf008{content}\uf009\uf003'
    text = SMALLCAPS.sub(smcpreplacement, text)

    # Step 6. Variables

    RIGHT_ASCENDER = ('d', 'f', 'i', 'j', 'l')
    LEFT_DESCENDER = ('g', 'j', 'p', 'y')

    vari = []
    def varreplacement(match : MatchObject) -> str:
        name = match[0][1:]
        vari.append(f'<span class="var">{name}</span>')
        lhs = '\uf004' if name[ 0] in LEFT_DESCENDER else ''
        rhs = '\uf004' if name[-1] in RIGHT_ASCENDER else ''
        return f'{lhs}\uf005{rhs}'
    text = VARIABLE.sub(varreplacement, text)

    # Step 7. Superscripts and Subscripts
    #   These must be preceded by a non-whitespace character.
    #
    #    ^num  or   ^@xxx  or   ^{xxx}  becomes  <sup>...</sup>
    #    _num  or   _@xxx  or   _{xxx}  becomes  <sub>...</sub>
    #   __num  or  __@xxx  or  __{xxx}  becomes  <sub class="sm">...</sub>

    scps = []
    def scriptreplacement(match : MatchObject) -> str:
        mark, content = match[1], match[2]
        name = 'sup' if mark[0] == '^' else 'sub'
        attr = ' class="sm"' if len(mark) > 1 else ''
        opening, closing = f'<{name}{attr}>', f'</{name}>'
        if content[0] == '{':
            content = content[1:-1].strip()
        scps.append(opening)
        scps.append(closing)
        return f'\uf006\uf008{content}\uf009\uf006'
    text = SCRIPT.sub(scriptreplacement, text)

    # Step 8. Delimiters and Operators

    correction = {
        '(': 0.0625,    # (p
        ')': 0.0625,    #  d)
        '[': 0.0625,    # [p
        ']': 0.0625,    #  d]
    }
    delimspace = {
        '(': 0.0625,    # x(
        ')': 0,         # )x
        '[': 0.0625,    # x[
        ']': 0,         # ]x
    }
    binopspace = 0.125

    cxws = []

    parts = [p for p in CONTEXTWS.split(text) if len(p) > 0]
    repls = {}
    stop = len(parts) - 1
    for idx, char in enumerate(parts):
        if len(char) > 1:
            continue

        lhs, rhs = 0, 0

        if char in ('(', '['):
            if idx > 0 and (match := RLETR.search(parts[idx-1])) is not None:
                lhs = delimspace[char]
                if match.group(1) == '\uf004':
                    lhs = max(lhs, correction[char])
            if idx < stop and (match := LLETR.search(parts[idx+1])) is not None:
                if match.group(1) == '\uf004':
                    rhs = correction[char]
            if lhs == 0 and rhs == 0:
                continue

        elif char in (')', ']'):
            if idx < stop and (match := LLETR.search(parts[idx+1])) is not None:
                rhs = delimspace[char]
                if match.group(1) == '\uf004':
                    rhs = max(rhs, correction[char])
            if idx > 0 and (match := RLETR.search(parts[idx-1])) is not None:
                if match.group(1) == '\uf004':
                    lhs = correction[char]
            if lhs == 0 and rhs == 0:
                continue

        elif char in {'+', '−', '×', '÷', '⋅'}:
            if idx == 0 or idx == stop: continue
            if RCHAR.search(parts[idx-1]) is None: continue
            if LCHAR.search(parts[idx+1]) is None: continue
            lhs = binopspace
            rhs = binopspace

        else:
            continue

        mgn = []
        if lhs != 0: mgn.append(f'margin-left: {lhs}em;')
        if rhs != 0: mgn.append(f'margin-right: {rhs}em;')
        mgn = " ".join(mgn)

        cxws.append(f'<span style="{mgn}">{char}</span>')
        repls[idx] = '\uf007'

    for idx, char in repls.items():
        parts[idx] = char
    text = ''.join(parts)

    # Step 9. Italic and Bold
    #   The markdown "***fst** snd*" should become "<i><b>fst</b> snd</i>"
    #     and not "<b><i>fst</b> snd</i>".
    #   Similarly, "***fst* snd**" should become "<b><i>fst</i> snd</b>"
    #     and not "<i><b>fst</i> snd</b>".
    #   This is impossible to decide correctly without lookahead,
    #     so we simply ignore three or more contiguous asterisks.

    italic = False

    def fmtopen(sigil : str) -> str:
        nonlocal italic
        if sigil == '**':
            return '<b>'
        italic = not italic
        return '<i>' if italic else '<span class="ni">'

    def fmtclose(sigil : str) -> str:
        nonlocal italic
        if sigil == '**':
            return '</b>'
        closing = '</i>' if italic else '</span>'
        italic = not italic
        return closing

    fmtstacks = [[]]

    def fmtreplacement(match : MatchObject) -> str:
        nonlocal italic
        sigil = match[0]
        # \uf008 begins a new stack and \uf009 ends it
        if sigil == '\uf008':
            fmtstacks.append([])
            return ''
        if sigil == '\uf009':
            stack = fmtstacks.pop()
            if len(stack) == 0:
                return ''
            return ''.join(fmtclose(excess) for excess in reversed(stack))
        if len(sigil) > 2:
            return sigil
        stack = fmtstacks[-1]
        if sigil in stack:
            if stack[-1] != sigil:
                return sigil
            stack.pop()
            return fmtclose(sigil)
        stack.append(sigil)
        return fmtopen(sigil)

    text = FORMATTER.sub(fmtreplacement, text)

    stack = fmtstacks[-1]
    if len(stack) > 0:
        text = text + ''.join(fmtclose(sigil) for sigil in reversed(stack))

    # Step 10. Custom Transformations

    text = text.replace(
        '...',
        '<span style="letter-spacing: 0.125em;">...</span>'
    )

    if MIDRENDERFILTER is not None:
        text = MIDRENDERFILTER(text)

    # Step 11. Substitute everything back in, and we're done!

    #                                           \uf009   itbf
    #                                           \uf008   itbf
    if len(cxws) > 0: text = replacelist(text, '\uf007', cxws)
    if len(scps) > 0: text = replacelist(text, '\uf006', scps)
    if len(vari) > 0: text = replacelist(text, '\uf005', vari)
    if len(vari) > 0: text =     text.replace( '\uf004', ''  )
    if len(smcp) > 0: text = replacelist(text, '\uf003', smcp)
    if len(lnks) > 0: text = replacelist(text, '\uf002', lnks)
    if len(math) > 0: text = replacelist(text, '\uf00a', math)
    if len(code) > 0: text = replacelist(text, '\uf001', code)
    if len(tags) > 0: text = replacelist(text, '\uf000', tags)

    # en    1/2 em
    # word  1/4 em
    # thin  1/6 em
    # hair  1/10 em
    # twlf  1/12 em
    # mu    1/24 em
    text = text.replace('&ensp;',   '<span class="en"> </span>')
    text = text.replace('&thinsp;', '<span class="sx"> </span>')
    text = text.replace('&hairsp;', '<span class="dc"> </span>')
    text = text.replace('&twlfsp;', '<span class="tw"> </span>')
    text = text.replace('&musp;',   '<span class="mu"> </span>')

    text = text.replace('†{{', '<span class="lt">')
    text = text.replace('{{', '<span style="display: inline-block;">')
    text = text.replace('}}', '</span>')

    if POSTRENDERFILTER is not None:
        text = POSTRENDERFILTER(text)

    return text

#  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
# These subroutines create different HTML elements.

INDENT = re.compile(r'\s*\|(\d?)>')

ALIGNMENT = re.compile(r' *\|(?: *(?::? *-+ *:? *)\|)+ *')

ANCHOR = re.compile(r'\{(#)?\s*([a-zA-Z0-9_+-]*)\s*\}')

def makehead(lines : list[str], ga : bool, gb : bool, margin : int) -> str:
    # If the line begins with {name} the element will have its ID set to name
    # If the line begins with {!name} the heading will also have a permalink
    assert len(lines) == 1
    inner = lines[0].lstrip('#')
    level = len(lines[0]) - len(inner)
    assert 6 >= level >= 1
    inner = inner.strip()

    match = ANCHOR.match(inner)
    if match is not None:
        name = match.group(2)
        inner = inner[match.end():].lstrip()
        if match.group(1) is not None:
            inner = f'<a href="#{name}">{PERMALINK}</a> {inner}'
    else:
        name = None

    opening, closing = tagpair(f'h{level}', ga, gb, name=name)
    mgn = ' ' * margin
    html = render(inner)
    return f'{mgn}{opening}{html}{closing}'


def makepara(lines : list[str], ga : bool, gb : bool, margin : int) -> str:

    lines = [*lines]

    # Step 1. Escape Sequences

    for idx in range(len(lines)):
        ln = lines[idx]
        if r'\<' in ln:
            ln = ln.replace(r'\<', '&lt;')
        if r'\>' in ln:
            ln = ln.replace(r'\>', '&gt;')
        lines[idx] = ln

    # Step 2. Perform line transformations.

    for idx in range(len(lines)):
        ln = lines[idx]
        match = INDENT.match(ln)
        if match is None: continue
        if len(match.group(1)) == 0:
            style = f'display: block; text-align: center;'
        else:
            style = 'display: block;'
            length = round(int(match.group(1)) * INDENTSIZE, 3)
            if length > 0:
                style = f'{style} margin-left: {length}em;'
        body = ln[match.end():].strip()
        lines[idx] = (f'<span style="{style}">{body}</span>')

    # Step 3. Break the text at elements that are likely to be block-level.

    ENCLOSED   = 0  # render and enclose in a paragraph tag
    UNENCLOSED = 1  # render
    VERBATIM   = 2

    # This is a list of (int, str) where the integer indicates whether we need
    #   to enclose the content in a paragraph tag or emit the text verbatim.
    parts = []

    text = '\n'.join(lines)
    # emitted   everything before this index has been written to parts
    # offset    everything at or after this index has not been examined
    emitted, offset = 0, 0
    stack = []
    while (next_tag := parsetag(text, offset)) is not None:
        action, name, attrs, tag_start, rem_start = next_tag
        offset = rem_start
        if name not in BREAKING:
            continue

        if action == 'open':
            if len(stack) == 0:
                content = text[emitted:tag_start].strip()
                if len(content) > 0:
                    parts.append((ENCLOSED, content))
                emitted = tag_start
                stack.append(name)
                continue
            # We make a reasonable simplifying assumption: a div can contain
            #   anything and a list can contain a list; otherwise, we auto-
            #   matically close the previous tag.
            nest = (
                stack[-1] == 'div'
                or (stack[-1] == 'li' and name in ('ol', 'ul', 'dl'))
            )
            if not nest:
                stack.pop()
            stack.append(name)

        if action == 'close':
            if len(stack) > 0 and stack[-1] == name:
                stack.pop()
                if len(stack) > 0:
                    continue
            # If this is a closing tag that we just popped off the stack and
            #   the stack is now empty as a result, we've seen the outermost
            #   element in its entirety.
            # If this is an unexpected closing tag, we can't be sure, but
            #   the content probably belongs to a handwritten element.
            kind = VERBATIM if name == 'pre' else UNENCLOSED
            parts.append((kind, text[emitted:rem_start]))
            emitted = rem_start

    content = text[emitted:].strip()
    if len(stack) == 0:
        if len(content) > 0:
            parts.append((ENCLOSED, content))
    else:
        kind = VERBATIM if 'pre' in stack else UNENCLOSED
        parts.append((kind, content))

    # Step 4. Render!

    num_parts = len(parts)
    assert num_parts > 0

    # Optimize the common case (when the paragraph didn't need to be broken up).
    if num_parts == 1:
        kind, fragment = parts[0]
        if kind == VERBATIM:
            return fragment
        html = render(fragment, escape=False)
        if kind == ENCLOSED:
            opening, closing = tagpair('p', ga, gb)
            html = f'{opening}{html}{closing}'
        if margin > 0:
            fst = ' ' * margin
            rst = fst + '  '
            html = "\n".join(
                (fst if idx == 0 else rst) + ln if len(ln) > 0 else ln
                for idx, ln in enumerate(html.split("\n"))
            )
        return html

    # Now we handle the general case.
    total_html = []
    L = num_parts - 1
    for index, (kind, fragment) in enumerate(parts):
        if kind == VERBATIM:
            total_html.append(fragment)
            continue
        html = render(fragment, escape=False)
        if kind == ENCLOSED:
            op, cl = tagpair('p', ga and index == 0, gb and index == L)
            html = f'{op}{html}{cl}'
        if margin > 0:
            fst = ' ' * margin
            rst = fst + '  '
            html = "\n".join(
                (fst if idx == 0 else rst) + ln if len(ln) > 0 else ln
                for ln in html.split("\n")
            )
        total_html.append(html)

    return '\n'.join(total_html)


def makelist(lines : list[str], ga : bool, gb : bool, margin : int) -> str:
    joined = []
    for ln in lines:
        lstripped = ln.lstrip()
        indent = len(ln) - len(lstripped)
        bullet = lstripped[0]
        if bullet in ('*', '-', '+'):
            content = lstripped[1:].strip()
        else:
            indent, bullet, partial = joined.pop()
            content = f'{partial} {lstripped.rstrip()}'
        joined.append((indent, bullet, content))

    mgn = ' ' * margin
    opening, closing = tagpair('ul', ga, gb)
    html_lines = [mgn + opening]
    stack = []  # list of (indent, bullet) pairs

    for indent, bullet, content in joined:
        html = render(content)

        if len(stack) == 0:
            # This is the first line.
            html_lines.append(f'{mgn}  <li>{html}</li>')
            stack.append((indent, bullet))
            continue

        while indent < stack[-1][0]:
            stack.pop()
            if len(stack) == 0:
                return makecode(lines, ga, gb, margin)
            if indent != stack[-1][0]:
                return makecode(lines, ga, gb, margin)
            # Finish the list.
            leftskip = '  ' * len(stack)
            html_lines.append(f'{mgn}{leftskip}</ul></li>')

        if indent == stack[-1][0]:
            if bullet != stack[-1][1]:
                return makecode(lines, ga, gb, margin)
            # Continue the current list.
            leftskip = '  ' * len(stack)
            html_lines.append(f'{mgn}{leftskip}<li>{html}</li>')
            continue

        # Start a new list.
        leftskip = '  ' * len(stack)
        html_lines.append(f'{mgn}{leftskip}<li style="list-style: none;"><ul>')
        html_lines.append(f'{mgn}{leftskip}  <li>{html}</li>')
        stack.append((indent, bullet))

    # Finish the list.
    while len(stack) > 1:
        stack.pop()
        leftskip = '  ' * len(stack)
        html_lines.append(f'{mgn}{leftskip}</ul></li>')

    html_lines.append(mgn + closing)
    return '\n'.join(html_lines)


def maketabl(lines : list[str], ga : bool, gb : bool, margin : int) -> str:
    bottomup = []
    header, alignment = None, None
    for ln in reversed(lines):
        if ALIGNMENT.fullmatch(ln):
            if alignment is not None:
                return makecode(lines, ga, gb, margin)
            alignment = []
            ln = ln.strip().removeprefix('|').removesuffix('|')
            for column in ln.split('|'):
                column = column.strip()
                L = column[ 0] == ':'
                R = column[-1] == ':'
                if L and R: alignment.append('center')
                elif L:     alignment.append('left')
                elif R:     alignment.append('right')
                else:       alignment.append(None)
            continue
        row = []
        ln = ln.replace(r'\|', '&#x7C')
        ln = ln.strip().removeprefix('|').removesuffix('|')
        for cell in ln.split('|'):
            row.append(render(cell.strip()))
        if alignment is None:
            bottomup.append(row)
            continue
        if header is None:
            header = row
            continue
        return makecode(lines, ga, gb, margin)

    num_columns = [len(row) for row in bottomup]
    if alignment is not None:
        num_columns.append(len(alignment))
    if header is not None:
        num_columns.append(len(header))

    support = min(num_columns)
    if support != max(num_columns):
        return makecode(lines, ga, gb, margin)

    if alignment is None:
        alignment = [''] * support
    else:
        alignment = [
            ('' if align is None else f' class="{align}"')
            for align in alignment
        ]

    mgn = ' ' * margin
    opening, closing = tagpair('table', ga, gb)
    html_lines = [mgn + opening]

    if header is not None:
        html_lines.append(f'{mgn}  <thead>')
        html_lines.append(f'{mgn}    <tr>')
        for idx, cell in enumerate(header):
            html_lines.append(f'{mgn}      <th{alignment[idx]}>{cell}</th>')
        html_lines.append(f'{mgn}    </tr>')
        html_lines.append(f'{mgn}  </thead>')

    html_lines.append(f'{mgn}  <tbody>')
    for row in reversed(bottomup):
        html_lines.append(f'{mgn}    <tr>')
        for idx, cell in enumerate(row):
            html_lines.append(f'{mgn}      <td{alignment[idx]}>{cell}</td>')
        html_lines.append(f'{mgn}    </tr>')
    html_lines.append(f'{mgn}  </tbody>')

    html_lines.append(mgn + closing)
    return '\n'.join(html_lines)


LANG = re.compile(r'[a-zA-Z]+')


def makecode(
    lines : list[str],
    ga : bool,
    gb : bool,
    margin : int,
    lang : str = None
) -> str:
    classes = None
    inner = '\n'.join(lines)
    if CODEBLOCKCLASS is not None:
        classes = CODEBLOCKCLASS(inner, lang)
    if CODEBLOCKFILTER is not None:
        inner = CODEBLOCKFILTER(inner, lang)
    opening, closing = tagpair('pre', ga, gb, classes=classes)
    html = opening + inner + closing
    if margin > 0:
        mgn = ' ' * margin
        html = '\n'.join([
            mgn + '<!-- ↓↓↓ PREFORMATTED ↓↓↓ -->',
            html,
            mgn + '<!-- ↑↑↑ PREFORMATTED ↑↑↑ -->',
        ])
    return html


MATHALIGN = re.compile(r'(\d?)([><])')


def makemath(lines : list[str], ga : bool, gb : bool, margin : int) -> str:
    alignment = 'center'
    indent = None
    if len(lines) > 0:
        match = MATHALIGN.match(lines[0])
        if match is not None:
            if len(match.group(1)) > 0:
                length = round(int(match.group(1)) * INDENTSIZE, 3)
            else:
                length = 0
            if match.group(2) == '<':
                alignment = 'right'
                if length > 0: indent = f'padding-right: {length}em;'
            else:
                alignment = 'left'
                if length > 0: indent = f'padding-left: {length}em;'
            lines[0] = lines[0][match.end():]

    result = mathml.parse(' '.join(lines))
    if result is None:
        return makecode(lines, ga, gb, margin)

    opening, closing = tagpair('div', ga, gb, classes=alignment, style=indent)
    html_lines = [opening, *mathml.render(result, False, indent=1), closing]
    if margin > 0:
        mgn = ' ' * margin
        return '\n'.join(mgn + ln for ln in html_lines)

    return '\n'.join(html_lines)

#  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -

def makequot(lines : list[str], ga : bool, gb : bool, margin : int) -> str:
    leftskip = min(
        len(ln) - len(ln.lstrip())
        for ln in lines
    )
    lines = [ln[leftskip:] for ln in lines]
    inner = _convert(lines, margin+2)
    mgn = ' ' * margin
    opening, closing = tagpair('blockquote', ga, gb)
    return f'{mgn}{opening}\n{inner}\n{mgn}{closing}'


def bulleted(stripped : str) -> bool:
    return any(
        stripped.startswith(bullet)
        for bullet in ('* ', '- ', '+ ')
    )


def _convert(md_lines : str, margin : int) -> str:

    # This is a list of "gap" or (kind, [line]) pairs
    #   where kind is "head", "para", "list", "table", "code", or "math".
    blocks = []

    block_kind = None
    block_lines = []
    block_extra = None

    def finish() -> None:
        nonlocal block_kind, block_lines, block_extra
        if len(block_lines) == 0:
            block_kind = None
            block_extra = None
            return
        assert block_kind is not None
        blocks.append((block_kind, block_lines, block_extra))
        block_kind = None
        block_lines = []
        block_extra = None

    todo = list(reversed(md_lines))

    while len(todo) > 0:
        line = todo.pop()
        stripped = line.strip()

        if block_kind == 'code':
            if '```' not in line:
                block_lines.append(line)
                continue
            start = line.index('```')
            pre = line[:start]
            post = line[start+3:]
            if len(pre.strip()) > 0:
                block_lines.append(pre)
            finish()
            if len(post.strip()) > 0:
                todo.append(post)
            continue

        if block_kind == 'math':
            if '$$' not in line:
                block_lines.append(line)
                continue
            start = line.index('$$')
            pre = line[:start]
            post = line[start+2:]
            if len(pre.strip()) > 0:
                block_lines.append(pre)
            finish()
            if len(post.strip()) > 0:
                todo.append(post)
            continue

        if len(stripped) == 0:
            finish()
            blocks.append('gap')
            continue

        if stripped.startswith('//'):
            # In addition to <!-- multiline --> style comments, we support
            #   single line comments with // virgules (at the start of a line).
            continue

        if stripped.startswith('>'):
            start = line.index('>')
            rhs = line[start+1:]
            if block_kind == 'quot':
                block_lines.append(rhs)
                continue
            finish()
            block_kind = 'quot'
            block_lines.append(rhs)
            continue
        elif block_kind == 'quot':
            finish()

        if stripped.startswith('#'):
            assert '```' not in line
            assert '$$' not in line
            finish()
            block_kind = 'head'
            block_lines.append(line)
            finish()
            continue

        if stripped.startswith('|') and INDENT.match(line) is None:
            assert '```' not in line
            assert '$$' not in line
            if block_kind == 'tabl':
                block_lines.append(line)
                continue
            finish()
            block_kind = 'tabl'
            block_lines.append(line)
            continue
        elif block_kind == 'tabl':
            finish()

        if bulleted(stripped):
            assert '```' not in line
            assert '$$' not in line
            if block_kind == 'list':
                block_lines.append(line)
                continue
            finish()
            block_kind = 'list'
            block_lines.append(line)
            continue

        if stripped.startswith('```'):
            finish()
            block_kind = 'code'
            start = line.index('```')
            post = line[start+3:]
            ps = post.strip()
            if len(ps) > 0:
                if LANG.fullmatch(ps):
                    block_extra = ps
                else:
                    todo.append(post)
            continue

        if stripped.startswith('$$'):
            finish()
            block_kind = 'math'
            start = line.index('$$')
            post = line[start+2:]
            if len(post.strip()) > 0:
                todo.append(post)
            continue

        if '```' in line:
            start = line.index('```')
            pre = line[:start]
            rem = line[start:]
            line = pre
            todo.append(rem)

            if len(line.strip()) == 0:
                continue

        if '$$' in line:
            start = line.index('$$')
            pre = line[:start]
            rem = line[start:]
            line = pre
            todo.append(rem)

            if len(line.strip()) == 0:
                continue

        if block_kind == 'list':
            indent = len(line) - len(line.lstrip())
            if indent > 0:
                block_lines.append(line)
                continue
            finish()

        if block_kind is None:
            assert len(block_lines) == 0
            block_kind = 'para'
        else:
            assert block_kind == 'para'

        block_lines.append(line)

    finish()

    # Before iterating over the blocks,
    #   we deduplicate gaps and join adjacent lists.

    filtered = []
    gap_above = False
    for item in blocks:
        if item == 'gap':
            gap_above = True
            continue
        if len(filtered) == 0:
            filtered.append(item)
            gap_above = False
            continue
        kind, lines, _ = item
        prev = filtered[-1]
        if kind == 'list' and prev != 'gap' and prev[0] == 'list':
            prev[1].extend(lines)
            gap_above = False
            continue
        if gap_above:
            filtered.append('gap')
            gap_above = False
        filtered.append(item)

    blocks = filtered

    # Now we can finally render each block
    #   and join them to produce output!

    total_html = list()

    L = len(blocks) - 1
    for index, item in enumerate(blocks):
        if item == 'gap':
            continue
        gap_above = index > 0 and blocks[index-1] == 'gap'
        gap_below = index < L and blocks[index+1] == 'gap'
        kind, lines, extra = item
        if   kind == 'para': html = makepara(lines, gap_above, gap_below, margin)
        elif kind == 'math': html = makemath(lines, gap_above, gap_below, margin)
        elif kind == 'code': html = makecode(lines, gap_above, gap_below, margin, extra)
        elif kind == 'list': html = makelist(lines, gap_above, gap_below, margin)
        elif kind == 'tabl': html = maketabl(lines, gap_above, gap_below, margin)
        elif kind == 'head': html = makehead(lines, gap_above, gap_below, margin)
        elif kind == 'quot': html = makequot(lines, gap_above, gap_below, margin)
        total_html.append(html)

    return '\n'.join(total_html)

#  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -
# This routine converts any fragment of markdown.

def convert(markdown : str, margin : int = 0) -> str:
    # This routine is responsible for:
    #   headings, paragraphs, lists, tables, code blocks

    # HTML comments are not nestable.
    parts = []
    index = 0
    while True:
        try: comment_start = markdown.index('<!--', index)
        except ValueError: break
        try: comment_end = markdown.index('-->', comment_start+4)
        except ValueError: break
        parts.append(markdown[index:comment_start])
        index = comment_end+3
    if index > 0:
        if index < len(markdown):
            parts.append(markdown[index:])
        markdown = ''.join(parts)

    return _convert(markdown.splitlines(), margin)

#  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -

if __name__ == '__main__':
    from os import path
    from sys import argv, exit, stderr
    from runpy import run_path

    args = argv[1:]
    if len(args) == 0 or '-h' in args or '--help' in args:
        print(
            f'usage: {argv[0]} [-x <module>] [-l <css>] [-i <css>] <markdown>',
            file=stderr
        )
        exit()
    args = list(reversed(args))

    icon = None
    title = None
    linked  = []
    inlines = []
    sources = []
    while len(args) > 0:
        arg = args.pop()
        if arg == '-t' or arg == '--title':
            title = args.pop()
        elif arg == '-p' or arg == '--icon':
            icon = args.pop()
        elif arg == '-l' or arg == '--link':
            linked.append(args.pop())
        elif arg == '-i' or arg == '--inline':
            inlines.append(args.pop())
        elif arg == '-x' or arg == '--extension':
            glob = run_path(args.pop())
            if 'INDENTSIZE' in glob: INDENTSIZE       = glob['INDENTSIZE']
            if 'PERMALINK'  in glob: PERMALINK        = glob['PERMALINK']
            if 'prerender'  in glob: PRERENDERFILTER  = glob['prerender']
            if 'midrender'  in glob: MIDRENDERFILTER  = glob['midrender']
            if 'postrender' in glob: POSTRENDERFILTER = glob['postrender']
            if 'codeblock'  in glob: CODEBLOCKFILTER  = glob['codeblock']
            if 'blockclass' in glob: CODEBLOCKCLASS   = glob['blockclass']
        else:
            sources.append(arg)

    if len(sources) == 0:
        exit()

    links = []
    if icon is not None:
        icon = icon.split(',')
        icon = icon[0]
        mime = icon[1] if len(icon) > 1 else 'gif'
        links.append(f'<link rel="icon" href="{icon}" type="image/{mime}"/>')
    links.extend(
        f'<link rel="stylesheet" href="{link}" type="text/css"/>\n'
        for link in linked
    )
    links = ''.join(links)

    css = []
    for inl in inlines:
        with open(inl) as fh:
            for ln in fh:
                ln = ln.rstrip()
                css.append(f'  {ln}\n' if len(ln) > 0 else ln)
    if len(css) > 0:
        css = f'<style>\n{"".join(css)}</style>\n'
    else:
        css = ""

    def makepage(title_elem : str, body : str) -> str:
        return (
            '<!DOCTYPE html>\n'
            '<meta charset="utf-8">\n'
            '<meta name="viewport"'
            ' content="width=device-width,'
            ' height=device-height,'
            ' initial-scale=1.0">\n'
           f'<title>{title_elem}</title>\n'
           f'{links}'
           f'{css}'
            '<div id="chase">\n'
            '  <div id="block">\n'
           f'{body}\n'
            '  </div>\n'
            '</div>\n'
        )

    for src in sources:
        with open(src) as fh:
            md = fh.read()
        html = convert(md, 4)
        base, _ = path.splitext(src)
        title_elem = base if title is None else title
        html = makepage(title_elem, html)
        with open(f'{base}.html', 'w') as fh:
            print(html, file=fh)
